Title: Retreaded: SoftwareDevelopmentAttitude
Date: 2014-03-11 13:05
Slug: retreaded-softwaredevelopmentattitude

[Retread](http://martinfowler.com/bliki/Retread.html) of post orginally
made on 08 Mar 2004

</p>

Many debates in software development are underpinned by whether

the speaker has a
[DirectingAttitude](http://martinfowler.com/bliki/DirectingAttitude.html)
or an

[EnablingAttitude](http://martinfowler.com/bliki/EnablingAttitude.html).
These different attitudes affect choices

over languages, designs, tools, processes, and lots more.

</p>

Here's some examples of this dichotomy:

</p>

-   A debate a while ago triggered by Joel Spolsky's post on
    [exceptions](http://www.joelonsoftware.com/items/2003/10/13.html).

    </p>

    He didn't like exceptions because they could be misused badly,
    leading

    to confusing code (directing). Bill Caputo
    <a href="http://www.williamcaputo.com/archives/000009.html">pointed

    out</a> that exceptions, when used well, make life much easier

    <p>
    (enabling).

-   Some of the static/dynamic typing debate brings up these

    </p>
    points. Some arguments in favor of static typing talk about how they

    prevent people from making certain kinds of mistake (directing)
    while

    dynamic typers point out how static typing restricts some useful

    <p>
    idioms (enabling).

-   Agile processes are
    [PeopleOriented](http://martinfowler.com/bliki/PeopleOriented.html)
    (enabling),

    </p>
    while plan-driven methods seek to ensure that even a poor team can
    do

    <p>
    an acceptable job (directing).

These aren't hard-wired attitudes. Often people are directing in

some cases and enabling in others. But I think there is a deep strain

running through here, often a personality issue, that runs underneath

much discussion on how we do software. (I'm very much in the enabling

category, as if you can't tell.)

</p>

You might think that all restrictions on what a developer does

imply a directing attitude, but it's not that simple. As an example,

consider memory management. You can think of this as a directing

feature: programmers can't be trusted to manage memory correctly so

take away their ability to allocate memory. But I look at memory

management as an enabling technology - it takes away something I don't

*want* to worry about, so I can concentrate better on those

things I do care about. Steve [tied this thought
nicely](http://stevef.truemesh.com/archives/000206.html) onto the

difference between problems and difficulties.

</p>

reposted on 11 Mar 2014

</p>

<span
class="label">Share:</span>[![](http://martinfowler.com/t_mini-a.png)](https://twitter.com/intent/tweet?url=http://martinfowler.com/bliki/SoftwareDevelopmentAttitude.html&text=Bliki:%20SoftwareDevelopmentAttitude "Share on Twitter")[![](http://martinfowler.com/fb-icon-20.png)](https://facebook.com/sharer.php?u=http://martinfowler.com/bliki/SoftwareDevelopmentAttitude.html "Share on Facebook")[![](http://martinfowler.com/gplus-16.png)](https://plus.google.com/share?url=http://martinfowler.com/bliki/SoftwareDevelopmentAttitude.html "Share on Google Plus")

</p>

