<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>
    An example of preparatory refactoring - ciandcd</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="http://www.ciandcd.com/theme/css/bootstrap.css" rel="stylesheet" type="text/css"/>
  <link href="http://www.ciandcd.com/theme/css/main.css" rel="stylesheet" type="text/css"/>
  <link href="http://www.ciandcd.com/theme/css/pygment.css" rel="stylesheet" type="text/css"/>
  <link href="http://fonts.googleapis.com/css?family=Chelsea+Market" rel="stylesheet" type="text/css"/>
<link href="http://www.ciandcd.com/feeds/rss.xml" rel="alternate" type="application/atom+xml" title="ciandcd RSS" />


  <!--[if lt IE 9]>
    <script src="https://raw.github.com/aFarkas/html5shiv/master/dist/html5shiv.js"></script>
  <![endif]-->
</head>

<!--
bootstrap-itech - a Pelican theme using Bootstrap
-->
<body>
<a href="https://github.com/ciandcd">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" />
</a>
<!-- Header -->
<header><div class="container">
<h1 class="page-header"><a href="http://www.ciandcd.com/index.html">ciandcd</a>
<h4>continuous integration and continuous delivery</h4></h1>
</div></header>
<!-- /Header -->

<!-- Body -->
<section id="body"><div class="container-fluid">

<!-- Nav bar -->
<div class="row"><div class="col-lg-12">
<nav class="navbar navbar-default"><div class="collapse navbar-collapse">
<ul class="nav navbar-nav">
  <li><a href="http://www.ciandcd.com/index.html">Home</a></li>



</ul>
</div></nav>
</div></div>
<!-- /Nav bar -->

<!-- Main block -->
<div class="row">

<!-- Content -->
<div class="col-lg-9">
<article>
<h1>
    An example of preparatory refactoring</h1>

<div><p>There are various ways in which <a href="/articles/workflowsOfRefactoring/">refactoring can fit into our programming
    workflow</a>. One useful notion is that of Preparatory
    Refactoring. This is where I'm adding a new feature, and I see
    that the existing code is not structured in such a way that makes
    adding the feature easy. So first I refactor the code into the
    structure that makes it easy to add the feature, or as Kent Beck
    pithily put it <a href="https://twitter.com/kentbeck/status/250733358307500032">"make the change easy, then
    make the easy change"</a>.</p>

<p>In a recent Ruby Rogues podcast, <a href="http://jessitron.com">Jessica
    Kerr</a> gave a lovely metaphor for preparatory refactoring.
    </p>

<blockquote>
<p>It&#8217;s like I want to go 100 miles east but instead of just
      traipsing through the woods, I&#8217;m going to drive 20 miles north
      to the highway and then I&#8217;m going to go 100 miles east at three
      times the speed I could have if I just went straight there. When
      people are pushing you to just go straight there, sometimes you
      need to say, &#8220;Wait, I need to check the map and find the
      quickest route.&#8221; The preparatory refactoring does that for
      me.</p>

<p class="quote-attribution"><a href="http://devchat.tv/ruby-rogues/178-rr-book-club-refactoring-ruby-with-martin-fowler">-- Jessica Kerr</a></p>
</blockquote>

<img src="preparatory-refactoring-example/jessitron.png" width="600">
<p class="photoCaption"></p>
<p>Another good metaphor I've come across is putting tape over
    electrical sockets, door frames, skirting boards and the like
    when painting a wall. The taping isn't doing the painting, but by
    spending the time to cover things up first, the painting can be
    much quicker and easier.</p>

<p>General statements and metaphors are all very nice, but it's
    good to show an example. And recently I ran into an example myself
    that I thought may be worth sharing. </p>


<h2>The Starting Point</h2>

<p>My publication toolchain includes the ability to insert code
      from a live file into an article. By a "live file", I mean code
      that compiles and runs, usually a pedagogical (ie toy) example.
      Being able to slurp code from live files is really helpful as it
      avoids copy-paste problems and gives me confidence that the code in
      the article is code that actually compiles and passes tests. I
      mark the code sections by markers contained in comments.
      <a href="#footnote-irony">[1]</a></p>

<p>One thing I'm adding just now is the ability to highlight
      specific parts of these code fragments. This way I can take a
      line, or part of a line of code, and surround it with span
      elements in the html, allowing me to then use css to highlight
      it any way I want. You'll see examples of me doing this later on
      in this article, as it's particularly handy when discussing
      refactorings.</p>

<p>At the start of the programming episode I'm talking about
      here, I already had the ability to highlight a given line, or a
      span of code within a given line. I wanted to add a third
      capability, to highlight a range of lines.</p>

<p>In the source document for my article, I indicate I want to
      insert a code fragment with an <code>insertCode</code> XML
      element. My
      current highlighting then allows me to define a bunch of
      highlights. Here's an example</p>

<pre>
&lt;insertCode file = "Notification.java" fragment = "notification-with-error"&gt;
  &lt;highlight line="add\(" span="new.*e\)"/&gt;
  &lt;highlight line="map"/&gt;
&lt;/insertCode&gt;
</pre>

<p>This highlights some code like this</p>

<pre>public void addError(String message, Exception e) {
  errors.add(<p class="highlight">new Error(message, e)</p>);
}

public String errorMessage() {
  return errors.stream()
<p class="highlight">          .map(e -&gt; e.message)</p>
          .collect(Collectors.joining(", "));
}</pre>

<p>The <code>insertCode</code> element has attributes for the
      file path and the name of the fragment that I want to extract. I
      can then specify highlights with child elements. Each highlight
      specifies a line by providing a regexp which I use to match the
      line. I may provide a span attribute, another regexp, in which
      case the highlighting is only for the part of the line that
      matches that regexp. If I don't provide a span the highlight is
      applied to the entire line.</p>

<p>I had put the code that does the highlighting into its own
      class. Some separate code (which we don't need to worry about)
      extracts the code fragment from the source file, it then looks to see
      if we need any highlighting, if so it creates a CodeHighlighter
      object and tells it to do the highlighting. The invocation of
      the code higlighter looks something like this:</p>

<pre>output &lt;&lt; CodeHighlighter.new(insertCodeElement, codeFragment).call
</pre>

<p>This is using the method object pattern, where I use an
      object to represent a first-class function. I create the object with
      the arguments to that function, invoke another method to run the
      function which returns the result, and then let the method
      object be garbage collected away.</p>

<p>Here's the implementation of that highlighter:</p>

<pre>class CodeHighlighter
  def initialize insertCodeElement, fragment
    @data = insertCodeElement
    @fragment = fragment
  end
  def call
    @fragment.lines.map{|line| highlight_line line}.join
  end
  def highlight_line line
    highlights
      .select{|h| Regexp.new(h['line']).match(line)}
      .reduce(line){|acc, each| apply_markup acc, each}
  end
  def highlights
    @data.css('highlight')
  end
  def apply_markup line, element
    open = "&lt;span class = 'highlight'&gt;"
    close = "&lt;/span&gt;"                 
    if element.key? 'span'
      r = Regexp.new(element['span'])
      m = r.match line
      m.pre_match + open + m[0] + close + m.post_match
    else
      open + line.chomp + close + "\n"
    end
  end
end
</pre>

<p class="code-remark">The toolchain code is ruby, it uses the
      <a href="http://www.nokogiri.org">Nokogiri</a> library to manipulate XML</p>

<p>I haven't worried much about edge cases here, such as if I
      specify multiple highlights that overlap in ways that will mess
      up the display. After all, if I run into any of these problems I
      know where I live. Such is the luxury of writing code where I'm
      the only user.</p>

<h2>Testing the highlighter</h2>

<p>Testing the highlighter is pretty simple, it's a pure function
     that takes some input and emits some output. But there's a little
     machinery I put in my test class to make it easier to write
     tests. The first thing is that I like to keep the hunks of text
     for input and output in a separate file, which looks like
     this</p>

<p class="code-label">codeHighlighterHunks.txt&#8230;
</p>

<pre>  input
  
    private void validateDate(Notification note) {
      if (date == null) {
        note.addError("date is missing");
        return;
      }
  
      LocalDate parsedDate;
      try {
        parsedDate = LocalDate.parse(getDate());
      }
    } //end
  
  <p class="highlight">%%</p> one-line
  
    private void validateDate(Notification note) {
      if (date == null) {
  &lt;span class = 'highlight'&gt;      note.addError("date is missing");&lt;/span&gt;
        return;
      }
  
      LocalDate parsedDate;
      try {
        parsedDate = LocalDate.parse(getDate());
      }
    } //end
  
  <p class="highlight">%%</p> one-span
  
    private void validateDate(Notification note) {
      if (date == null) {
        note.&lt;span class = 'highlight'&gt;addError&lt;/span&gt;("date is missing");
        return;
      }
  
      LocalDate parsedDate;
      try {
        parsedDate = LocalDate.parse(getDate());
      }
    } //end
  &#8230;</pre>

<p>Here you see three hunks of text, separated by
     <code>%%</code>. The first hunk is my (first) input string, the
     next two are outputs for what happens with one line, and one span
     within a line. Each hunk has a key, which is the text following
     the <code>%%</code> on the line. I can then easily get at the
     hunks in my tester class</p>

<p class="code-label">class CodeHighlighterTester&#8230;
</p>

<pre>  def hunks
    raw = File.read('test/codeHighlighterHunks.txt').split("\n%%")
    raw.map {|r| process_raw_hunk r}.to_h
  end
  def process_raw_hunk hunk
    lines = hunk.lines
    key = lines.first.strip
    value = lines
      .drop(1)
      .drop_while {|line| (/[^[:space:]]/ !~ line)}
      .join
    return [key, value]
  end
</pre>

<p>With the ability to extract hunks easily, I can then reference
     them in my tests.</p>

<p class="code-label">class CodeHighlighterTester&#8230;
</p>

<pre>  def test_no_highlights
    assert_equal hunks['input'], with_highlights(form_element(""))
  end
  def test_one_line_highlight
    element = form_element "&lt;highlight line = 'missing'/&gt;"
    assert_equal hunks['one-line'], with_highlights(element)
  end
  def test_highlight_span
    element = form_element "&lt;highlight line = 'missing' span = 'addError'/&gt;"
    assert_equal hunks['one-span'], with_highlights(element)
  end
  def form_element s
    Nokogiri::XML("&lt;insertCode&gt;" + s + "&lt;/insertCode").root
  end  
  def with_highlights element, input = nil
    input ||= hunks['input']
    CodeHighlighter.new(element,input).call
  end
</pre>

<p>I could have used multi-line strings or here docs for
     this, but I think hunks of text are easier to work with.</p>

<h2>Adding a highlight range</h2>

<p>The new feature I wanted to add was to highlight a range of
     lines like this.</p>

<pre>&lt;insertCode file = "BookingRequest.java" fragment = "done"&gt;
  &lt;highlight-range start-line = "missing" end-line = "return"/&gt;
&lt;/insertCode&gt;
</pre>

<p>The start-line and end-line attributes are again regexps, to
     match the first and last lines in the range.</p>

<p>I started by adding a test for the new markup behavior,
     checked that it failed, then marked it to be skipped. I like to
     start by writing the test for the final behavior I want, since
     that clarifies to me both exactly what the outcome I want is, and
     also how I want my API to work. But if I'm going to do any
     preparatory refactoring, I don't want that test's failure to
     clutter my test output, so after watching it fail once, I skip it while I'm working on it.</p>

<p class="code-label">class CodeHighlighterTester&#8230;
</p>

<pre>  def test_highlight_range
    skip
    e = '&lt;highlight-range start-line = "(date == null)" end-line = "}"/&gt;'
    assert_equal hunks['range'], with_highlights(form_element(e))    
  end
</pre>

<p class="code-label">codeHighlighterHunks.txt&#8230;
</p>

<pre>  %% range
  
    private void validateDate(Notification note) {
  &lt;span class = 'highlight'&gt;    if (date == null) {
        note.addError("date is missing");
        return;
      }&lt;/span&gt;
  
      LocalDate parsedDate;
      try {
        parsedDate = LocalDate.parse(getDate());
      }
    } //end</pre>

<p>As I was thinking about how to approach it, I began by
     deciding that I could treat the code highlighting as a sequence
     of transformations on the supplied text. I could first apply any
     highlight-range transformation, and then follow them with the
     existing highlights. I can now transfer that thought from my mind
     to the code.</p>

<p>My first step is to simply use <a href="http://refactoring.com/catalog/extractMethod.html">Extract Method</a> on the entire body of <code>call</code></p>

<p class="code-label">class CodeHighlighter&#8230;
</p>

<pre>  def call 
<p class="highlight">    apply_highlights @fragment.lines</p>
  end
  def apply_highlights lines
    lines.map{|line| highlight_line line}.join
  end</pre>

<p>Now I introduce a nested, no-op function - that is one that
     just returns what you give it, without any change.</p>

<p class="code-label">class CodeHighlighter&#8230;
</p>

<pre>  def call
    apply_highlights(<p class="highlight">apply_ranges</p>(@fragment.lines))
  end
  def apply_ranges lines
    lines
  end</pre>

<p>This single refactoring is really the essence of this whole
     article, boiled down to a simple step. With this refactoring I'm
     doing a couple of things. First, by placing the
     <code>apply_ranges</code> method into the call, I'm making a
     place for my new functionality to go. But secondly, and perhaps
     more importantly, I'm immediately implementing this new function
     in such a way that it preserves the current behavior. To some
     extent, this ability to easily insert placeholder functions is one
     of the great advantages of structuring the highlighting
     behavior as a series of smaller transformations - which is one of
     the reasons why the <a href="http://www.amazon.com/gp/product/0471958697?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0471958697">Pipes and Filters
     pattern</a><img src="http://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt=""> is such powerful way of structuring computation.
     </p>

<h2>The Two Hats</h2>

<img src="preparatory-refactoring-example/two-hats.png" width="200">
<p class="photoCaption"></p>
<p>In <a href="/books/refactoring.html">the Refactoring book</a>, I passed on Kent's metaphor of the
       two hats. His notion is that when you're programming, you can
       operate in one of two modes: refactoring and adding function.
       When you're wearing the refactoring hat, every change you make
       preservers observable behavior, keeps the tests green, and
       allows you to make many small changes without going near a
       debugger. </p>

<p>When you add function, however, things are more open
       ended as you will add tests and break existing tests. The
       adding function hat is more stressful and riskier, so it's nice
       to wear the refactoring hat as much as possible.</p>
<p>By defining <code>apply_ranges</code> with this simple
     behavior-preserving implementation, as opposed to just leaving it
     blank, I can continue to run my tests and keep my refactoring hat
     on.</p>

<p>I may have any number of highlight-range elements to apply, so
     I'll let each one compose on top the others.</p>

<p class="code-label">class CodeHighlighter&#8230;
</p>

<pre>  def apply_ranges lines
    highlight_ranges.reduce(lines){|acc, each| apply_one_range(acc, each)}
  end
  def highlight_ranges
    @data.css('highlight-range')
  end
  def apply_one_range lines, element
    lines
  end</pre>

<p>You'll see I'm doing the same trick again, I implement
     <code>apply_ranges</code> by reducing the result of running
     <code>apply_one_range</code> for each highlight-range element. I
     provide an initial implementation of <code>apply_one_range</code>
     that preserves existing behavior and get to keep my trilby
     on. What I'm doing is steadily narrowing down the scope of the change in
     behavior I'm about to add.</p>

<p>At this point, I add a no-op test for the highlight range
     condition.</p>

<p class="code-label">class CodeHighlighterTester&#8230;
</p>

<pre>  def test_highlight_range_noop
    e = '&lt;highlight-range start-line = "(date == null)" end-line = "}"/&gt;'
    assert_equal <p class="highlight">hunks['input']</p>, with_highlights(form_element(e))    
  end
</pre>

<p>This might seem like an odd move, essentially all this test
     says is that when I add a highlight-range element, I don't want
     any changes to the output. This is a temporary test, just while
     I'm working on the preparatory refactoring. While I'm doing this
     refactoring, I'm operating on the assumption that the
     refactorings I'm doing will result in no changes, even when the
     element is present. So I want to confirm that assumption with a
     test, since it's so easy to write. (This follows a general rule
     of mine: if I ever feel the urge to run the code and look at some
     output to see if things are correct, I should instead write a
     test. With a test the computer can check if the output is
     correct, so I don't have to.)</p>

<p>My next move is back to the highlighter itself. I've now
     isolated a method to highlight a single range. I think that a good
     thing to do next is to identify the line where I want to add the opening tag,
     and split the lines into three lists: before the matched line,
     the line alone, and after the matched line. I'll worry about the
     closing tag later.</p>

<p class="code-label">class CodeHighlighter&#8230;
</p>

<pre>  def apply_one_range lines, element
    start_ix = lines.find_index {|line| line =~ Regexp.new(element['start-line'])}
    pre = 0 == start_ix ? [] : lines[0..(start_ix - 1)]
    start = [lines[start_ix]]
    rest = lines.size == (start_ix + 1) ? [] : lines[(start_ix + 1)..-1]
    return pre + start + rest
  end</pre>

<p>
       The essence of this refactoring is breaking down the text and
       putting it back together again, until I've broken it down to
       the right point to slip in the new behavior.
     </p>
<p>By doing this I can test that I can correctly break the list
     of lines into pieces and put them back together. Since there
     aren't always three pieces, this is a bit more awkward than you
     might first think. Since I had to put conditional logic in to
     check if the range started on the first or last-but-one line, I
     added some tests to check for these cases.</p>

<p>I'm only checking for the opening so far, and am almost ready
     to actually change the observable behavior, but first I need to
     move the html span strings into something at object
     scope.</p>

<p class="code-label">class CodeHighlighter&#8230;
</p>

<pre>  def apply_markup line, element
<p class="deleted">    open = "&lt;span class = 'highlight'&gt;"</p>
<p class="deleted">    close = "&lt;/span&gt;"</p>
    if element.key? 'span'
      r = Regexp.new(element['span'])
      m = r.match line
      raise "unable to match span %s" % element['span'] unless m
      m.pre_match + opening + m[0] + closing + m.post_match
    else
      opening + line.chomp + closing + "\n"
    end
  end

  def opening
    "&lt;span class = 'highlight'&gt;"
  end
  def closing
    "&lt;/span&gt;"
  end
</pre>

<p>I could make them constants, but it's my habit to just use
     methods in this situation. <a href="#footnote-css">[2]</a></p>

<p>Now I'm finally ready to put my hard-hat on, and the change I
     need to make is too trivial to be easy.</p>

<p class="code-label">class CodeHighlighter&#8230;
</p>

<pre>  def apply_one_range lines, element
    start_ix = lines.find_index {|line| line =~ Regexp.new(element['start-line'])}
    raise "unable to match %s in code insert" % element['start-line'] unless start_ix
    pre = 0 == start_ix ? [] : lines[0..(start_ix - 1)]
    start = [<p class="highlight">opening +</p> lines[start_ix]]
    rest = lines.size == (start_ix + 1) ? [] : lines[(start_ix + 1)..-1]
    return pre + start + rest
  end</pre>

<p>I now remove the no-op test I added a couple of minutes ago,
     and modify the skipped test so it only includes the opening. </p>

<p class="code-label">class CodeHighlighterTester&#8230;
</p>

<pre>  def test_highlight_range
    <p class="deleted">skip</p>
    e = '&lt;highlight-range start-line = "(date == null)" end-line = "}"/&gt;'
    assert_equal hunks['range'], with_highlights(form_element(e))    
  end
</pre>

<p class="code-label">codeHighlighterHunks.txt&#8230;
</p>

<pre>  %% range
  
    private void validateDate(Notification note) {
  &lt;span class = 'highlight'&gt;    if (date == null) {
        note.addError("date is missing");
        return;
      }<p class="deleted">&lt;/span&gt;</p>
  
      LocalDate parsedDate;
      try {
        parsedDate = LocalDate.parse(getDate());
      }
    } //end</pre>

<p>This testing allows me to do a little preparatory refactoring
     before I add the closing tag.</p>

<p class="code-label">class CodeHighlighter&#8230;
</p>

<pre>  def apply_one_range lines, element
    start_ix = lines.find_index {|line| line =~ Regexp.new(element['start-line'])}
    raise "unable to match %s in code insert" % element['start-line'] unless start_ix
<p class="highlight">    finish_offset = lines[start_ix..-1].find_index do |line| 
      line =~ Regexp.new(element['end-line'])
    end
    raise "unable to match %s in code insert" % element['end-line'] unless finish_offset
    finish_ix = start_ix + finish_offset</p>
    pre = 0 == start_ix ? [] : lines[0..(start_ix - 1)]
    start = [opening + lines[start_ix]]
<p class="highlight">    mid = (lines[(start_ix + 1)..(finish_ix -1)])
    finish = [lines[finish_ix]]
    rest = lines.size == (finish_ix + 1) ? [] : lines[(finish_ix + 1)..-1]</p>
    return pre + start + <p class="highlight">mid + finish</p> + rest
  end</pre>

<p>The method is rather long for my taste, but I can't think of
     how to sensibly shorten it. It does keep everything green and set
     things up for my final easy change.</p>

<p class="code-label">class CodeHighlighter&#8230;
</p>

<pre>  def apply_one_range lines, element
    start_ix = lines.find_index {|line| line =~ Regexp.new(element['start-line'])}
    raise "unable to match %s in code insert" % element['start-line'] unless start_ix
    finish_offset = lines[start_ix..-1].find_index do |line| 
      line =~ Regexp.new(element['end-line'])
    end
    raise "unable to match %s in code insert" % element['end-line'] unless finish_offset
    raise "start and end match same line" unless finish_offset &gt; 0
    finish_ix = start_ix + finish_offset
    pre = 0 == start_ix ? [] : lines[0..(start_ix - 1)]
    start = [opening + lines[start_ix]]
    mid = (lines[(start_ix + 1)..(finish_ix -1)])
<p class="highlight">    finish = [lines[finish_ix].chomp + closing + "\n"]</p>
    rest = lines.size == (finish_ix + 1) ? [] : lines[(finish_ix + 1)..-1]
    return pre + start + mid + finish + rest
  end
</pre>

<h2>Final Thoughts</h2>

<p>I hope this little episode has given you some sense of what
     preparatory refactoring can be like: </p>

<blockquote class="twitter-tweet" lang="en">
       for each desired change, make the change easy (warning: this may be hard), then make the easy change
     <a href="https://twitter.com/kentbeck/status/250733358307500032">-- Kent Beck</a></blockquote>
<p>I made the change easy by creating a no-op function that
     simply returned what it was given, and then decomposing that
     function, gradually breaking it down while still retaining its
     no-opiness. Then once it was simple to add the new feature, it just
     slipped in.</p>

<p>Every episode of preparatory refactoring is different. Some take
     a few minutes, some can take days. But I find that when I can
     spot how to do a preparatory refactoring it results in a faster
     and less-stressful programming experience, because the trilby is 
     faster and less stressful than the hard hat.</p>


<p class="shares">Share: <a href="https://twitter.com/intent/tweet?url=http://martinfowler.com/articles/preparatory-refactoring-example.html&amp;text=An%20example%20of%20preparatory%20refactoring" title="Share on Twitter"><img src="/t_mini-a.png"></a><a href="https://facebook.com/sharer.php?u=http://martinfowler.com/articles/preparatory-refactoring-example.html" title="Share on Facebook"><img src="/fb-icon-20.png"></a><a href="https://plus.google.com/share?url=http://martinfowler.com/articles/preparatory-refactoring-example.html" title="Share on Google Plus"><img src="/gplus-16.png"></a></p>

<h2>For articles on similar topics&#8230;</h2>

<p>&#8230;take a look at the tag: </p>
</div>

<p class="info">
Posted Sun 21 June 2015
 by <a class="url fn" href="http://www.ciandcd.com/author/itech001.html">itech001</a>
in <a href="http://www.ciandcd.com/category/devops.html">devops</a>
</p>

</article>
</div>
<!-- /Content -->

<!-- Side bar -->
<nav class="col-lg-3">

<h2>Categories</h2>
<ul class="nav nav-pills nav-stacked">
  <li ><a href="http://www.ciandcd.com/category/ciandcd.html">ciandcd</a></li>
  <li class="active"><a href="http://www.ciandcd.com/category/devops.html">devops</a></li>
  <li ><a href="http://www.ciandcd.com/category/scm.html">scm</a></li>
  <li ><a href="http://www.ciandcd.com/category/zh.html">zh</a></li>
</ul>

<h2>Links</h2>
<ul class="nav nav-pills nav-stacked">
  <li><a href="http://getpelican.com/">Pelican</a></li>
  <li><a href="http://python.org/">Python.org</a></li>
  <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
</ul>

<h2>Social</h2>
<ul class="nav nav-pills nav-stacked">
  <li><a href="http://www.ciandcd.com/feeds/rss.xml" type="application/rss+xml" rel="alternate">Site Feed</a></li>

  <li><a href="https://github.com/ciandcd">GITHUB</a></li>
</ul>

</nav>
<!-- /Side bar -->

</div>
<!-- /Main block -->

<!-- Footer -->
<div class="row"><div class="col-lg-12">
<footer><small>
Built using <a href="http://pelican.notmyidea.org/">Pelican</a> and
<a href="http://twitter.github.com/bootstrap">Bootstrap</a>.
</small></footer>
</div></div>
<!-- /Footer -->

</div></section>
<!-- /Body -->

<script src="http://www.ciandcd.com/theme/js/jquery.js"></script>
<script src="http://www.ciandcd.com/theme/js/bootstrap.js"></script>


</body>
</html>