<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>
    Replacing Throwing Exceptions with Notification in Validations - ciandcd</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="./theme/css/bootstrap.css" rel="stylesheet" type="text/css"/>
  <link href="./theme/css/main.css" rel="stylesheet" type="text/css"/>
  <link href="./theme/css/pygment.css" rel="stylesheet" type="text/css"/>
  <link href="http://fonts.googleapis.com/css?family=Chelsea+Market" rel="stylesheet" type="text/css"/>
<link href="./feeds/rss.xml" rel="alternate" type="application/atom+xml" title="ciandcd RSS" />


  <!--[if lt IE 9]>
    <script src="https://raw.github.com/aFarkas/html5shiv/master/dist/html5shiv.js"></script>
  <![endif]-->
</head>

<!--
bootstrap-itech - a Pelican theme using Bootstrap
-->
<body>
<a href="https://github.com/ciandcd">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" />
</a>
<!-- Header -->
<header><div class="container">
<h1 class="page-header"><a href="./index.html">ciandcd</a>
<h4>continuous integration and continuous delivery</h4></h1>
</div></header>
<!-- /Header -->

<!-- Body -->
<section id="body"><div class="container-fluid">

<!-- Nav bar -->
<div class="row"><div class="col-lg-12">
<nav class="navbar navbar-default"><div class="collapse navbar-collapse">
<ul class="nav navbar-nav">
  <li><a href="./index.html">Home</a></li>



</ul>
</div></nav>
</div></div>
<!-- /Nav bar -->

<!-- Main block -->
<div class="row">

<!-- Content -->
<div class="col-lg-9">
<article>
<h1>
    Replacing Throwing Exceptions with Notification in Validations</h1>

<div><p class="abstract"><i>
    If you're validating some data, you usually shouldn't be using
    exceptions to signal validation failures. Here I describe how I'd
    refactor such code into using the Notification pattern.
  </i></p><p>I was recently looking at some code to do some basic
    validation of some incoming JSON messages. It looked something like this. </p>

<pre>public void check() {
   if (date == null) throw new IllegalArgumentException("date is missing");
   LocalDate parsedDate;
   try {
     parsedDate = LocalDate.parse(date);
   }
   catch (DateTimeParseException e) {
     throw new IllegalArgumentException("Invalid format for date", e);
   }
   if (parsedDate.isBefore(LocalDate.now())) throw new IllegalArgumentException("date cannot be before today");
   if (numberOfSeats == null) throw new IllegalArgumentException("number of seats cannot be null");
   if (numberOfSeats &lt; 1) throw new IllegalArgumentException("number of seats must be positive");
 }</pre>

<p class="code-remark">The code for this example is Java</p>

<p>This is a common way to approach validation. You run a series
    of checks on some data (here just some fields within the class in
    question). If any of these checks fails, you throw an exception
    with an error message.</p>

<p>I have a couple of problems with this approach. Firstly I'm not
    happy with using exceptions for something like this. Exceptions
    signal something outside the expected bounds of behavior of the
    code in question. But if you're running some checks on outside input,
    this is because you expect some messages to fail - and if a
    failure is expected behavior, then you shouldn't be
    using exceptions.</p>

<p> if a failure is expected behavior, then you shouldn't
    be using exceptions </p>
<p>The second problem with code like this is that it fails with
    the first error it detects, but usually it's better to report all
    errors with the incoming data, not just the first. That way a
    client can choose to display all errors for the user to fix in a
    single interaction rather than give her the impression she's
    playing a game of whack-a-mole with the computer.</p>

<p>My preferred way to deal with reporting validation issues like
    this is the <a href="http://martinfowler.com/eaaDev/Notification.html">Notification
    pattern</a>. A notification is an object that collects errors,
     each validation failure adds an error to the notification. A
    validation method returns a notification, which you can then
    interrogate to get more information. A simple usage looks
    has code like this for the checks.</p>

<pre>private void validateNumberOfSeats(Notification note) {
  if (numberOfSeats &lt; 1) note.addError("number of seats must be positive");
  // more checks like this
}</pre>

<p>We can then have a simple call such as
    <code>aNotification.hasErrors()</code> to react if there are any
    errors. Other methods on the notification can drill into more
    details about the errors. <a href="#footnote-boolean">[1]</a></p>

<img src="replaceThrowWithNotification/sketch.png" width="600">
<p class="photoCaption"></p>

<h2>When to use this refactoring</h2>

<p>I need to stress here, that I'm not advocating getting rid of
      exceptions throughout your code base. Exceptions are a very
      useful technique for handling exceptional behavior and getting
      it away from the main flow of logic. This refactoring is a good
      one to use only when the outcome signaled by the exception
      isn't really exceptional, and thus should be handled through the
      main logic of the program. The example I'm looking at here,
      validation, is a common case of that.</p>

<p>A useful rule of thumb when considering exceptions comes
      from the Pragmatic Programmers:</p>

<blockquote>
<p>We believe that exceptions should rarely be used as part of
        a program's normal flow: exceptions should be reserved for
        unexpected events. Assume that an uncaught exception will
        terminate your program and ask yourself, "Will this code still
        run if I remove all the exception handlers?" If the answer is
        "no", then maybe exceptions are being used in nonexceptional
        circumstances.</p>

<p class="quote-attribution"><a href="http://www.amazon.com/gp/product/020161622X?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=020161622X">-- Dave Thomas and Andy Hunt</a><img src="http://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt=""></p>
</blockquote>

<p>An important consequence of this is that whether to use
      exceptions for a particular task is dependent on the context.
      So, as the prags go on to say, reading from a file that isn't
      there may or may not be an exception depending on the
      circumstances. If you are trying to read a well known file
      location, such as <code>/etc/hosts</code> on a unix system, then
      it's likely you can assume the file should be there, so
      throwing an exception is reasonable. On the other hand if you
      are trying to read a file from a path that the user has typed in
      on the command-line, then you should expect that it's likely the
      file isn't there, and should use another mechanism - one that
      communicates the unexceptional nature of the error.</p>

<p>There is a case when it may be sensible to use exceptions
      for validation failures. This would be situations where you have
      data that you expect to have already been validated earlier in
      processing, but you want to run the validation checks again to
      guard against a programming error letting some invalid data slip
      through.</p>

<p>This article is about replacing exceptions for notification
      in the context of validating raw input. You may also find this
      technique useful in other situations where a notification is a
      better choice than throwing an exception, but I'm focusing on
      the validation case here, as it is a common one.</p>

<h2>Starting Point</h2>

<p>I've not mentioned the example domain so far, since I was just
      interested in the broad shape of the code. But as we explore the
      example further, I'll need to engage with the domain. In this
      case it's some code that receives JSON messages booking seats at a
      theater. The code is in a booking request class that's populated
      from the JSON using the gson library.</p>

<pre>gson.fromJson(jsonString, BookingRequest.class)
</pre>

<p class="code-remark">Gson takes a class, looks for any fields that match a key in
      the JSON document, and then populates the matching fields.</p>

<p>The booking request contains just two elements that we
      are validating here, the date of the performance and how many
      seats are being requested</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  private Integer numberOfSeats; 
  private String date;
</pre>

<p>The validation checks are the ones I showed above</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  public void check() {
     if (date == null) throw new IllegalArgumentException("date is missing");
     LocalDate parsedDate;
     try {
       parsedDate = LocalDate.parse(date);
     }
     catch (DateTimeParseException e) {
       throw new IllegalArgumentException("Invalid format for date", e);
     }
     if (parsedDate.isBefore(LocalDate.now())) throw new IllegalArgumentException("date cannot be before today");
     if (numberOfSeats == null) throw new IllegalArgumentException("number of seats cannot be null");
     if (numberOfSeats &lt; 1) throw new IllegalArgumentException("number of seats must be positive");
   }</pre>

<h2>Building a Notification</h2>

<p>In order to use a notification, you have to create the
      notification object. A notification can be really simple,
      sometimes just a list of strings will do the trick. </p>

<p>A Notification collects together errors</p>
<pre>List&lt;String&gt; notification = new ArrayList&lt;&gt;();
if (numberOfSeats &lt; 5) notification.add("number of seats too small");
// do some more checks

// then later&#8230;
if ( ! notification.isEmpty()) // handle the error condition
</pre>

<p>Although a simple list idiom makes a lightweight implementation of
      the pattern, I usually like to do a bit more than this, creating
      a simple class instead. </p>

<pre>public class Notification {
  private List&lt;String&gt; errors = new ArrayList&lt;&gt;();

  public void addError(String message) { errors.add(message); }
  public boolean hasErrors() {
    return ! errors.isEmpty();
  }
  &#8230;
</pre>

<p>By using a real class, I can make my intention clearer - the
      reader doesn't have to perform the mental map between the idiom
      and its full meaning.</p>

<h2>Splitting the check method</h2>

<p>My first step is to split the check method into two parts, an
      inner part that will eventually deal only with notifications and
      not throw any exceptions, and an outer part that will preserve
      the current behavior of the check method, which is to throw an
      exception is there are any validation failures.</p>

<p>My first step to do this is to use <a href="http://refactoring.com/catalog/extractMethod.html">Extract Method</a> in an unusual way in that I'm extracting the
      entire body of the check method into a validation method.</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  public void check() {
<p class="highlight">    validation();</p>
  }

  public void validation() {
    if (date == null) throw new IllegalArgumentException("date is missing");
    LocalDate parsedDate;
    try {
      parsedDate = LocalDate.parse(date);
    }
    catch (DateTimeParseException e) {
      throw new IllegalArgumentException("Invalid format for date", e);
    }
    if (parsedDate.isBefore(LocalDate.now())) throw new IllegalArgumentException("date cannot be before today");
    if (numberOfSeats == null) throw new IllegalArgumentException("number of seats cannot be null");
    if (numberOfSeats &lt; 1) throw new IllegalArgumentException("number of seats must be positive");
  }</pre>

<p>I then adjust the validation method to create and return a
      notification.</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  public Notification validation() {
<p class="highlight">    Notification note = new Notification();</p>
    if (date == null) throw new IllegalArgumentException("date is missing");
    LocalDate parsedDate;
    try {
      parsedDate = LocalDate.parse(date);
    }
    catch (DateTimeParseException e) {
      throw new IllegalArgumentException("Invalid format for date", e);
    }
    if (parsedDate.isBefore(LocalDate.now())) throw new IllegalArgumentException("date cannot be before today");
    if (numberOfSeats == null) throw new IllegalArgumentException("number of seats cannot be null");
    if (numberOfSeats &lt; 1) throw new IllegalArgumentException("number of seats must be positive");
<p class="highlight">    return note;</p>
  }</pre>

<p>I can now test the notification and throw an exception if it
      contains errors.</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  public void check() {
<p class="highlight">    if (validation().hasErrors()) 
      throw new IllegalArgumentException(validation().errorMessage());</p>
  }</pre>

<p>I made the validation method public, because I'm expecting
      that most callers in the future will prefer to use this method,
      rather than the check method.</p>

<p>Splitting the original method allows me to separate the
      validation check from the decision about how to respond to failure.</p>
<p>At this point I haven't changed the behavior of the code at
      all, the notification won't contain any errors and any
      validation checks that fail will continue to throw an exception
      and ignore the new machinery I've put in. But I've now set
      things up ready to start replacing exception throws with
      manipulating the notification.</p>

<p>Before I go on to that, however, I need to say something
      about error messages. When we're doing a refactoring, the rule
      is to avoid changes in observable behavior. In situations like
      this, such a rule leads immediately to the question of what
      behavior is observable. Obviously the throwing of the correct
      exception is something the outer program will observe - but to
      what extent do they care about the error message? The
      notification will eventually collect multiple errors and could
      summarize them together into a single message with something
      like</p>

<p class="code-label">class Notification&#8230;
</p>

<pre>  public String errorMessage() {
    return errors.stream()
      .collect(Collectors.joining(", "));
  }
</pre>

<p>But that would be a problem if the higher levels of the
      program was relying on only getting the message from the first
      error that's detected, in which case you'd need something like</p>

<p class="code-label">class Notification&#8230;
</p>

<pre>  public String errorMessage() { return errors.get(0); }
</pre>

<p>You have to look not just at the calling function, but also
      any exception handlers to figure out what the right response is
      in this situation.</p>

<p>Although there's no way I should have introduced any problems
      at this point, I would certainly compile and test before making
      the next changes. Just because there's no chance any sensible
      person could have messed those changes up doesn't mean I can't
      mess it up.</p>

<h2>Validating the number</h2>

<p>The obvious thing to do now is to replace the first
      validation</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  public Notification validation() {
    Notification note = new Notification();
    if (date == null) <p class="highlight">note.addError</p>("date is missing");
    LocalDate parsedDate;
    try {
      parsedDate = LocalDate.parse(date);
    }
    catch (DateTimeParseException e) {
      throw new IllegalArgumentException("Invalid format for date", e);
    }
    if (parsedDate.isBefore(LocalDate.now())) throw new IllegalArgumentException("date cannot be before today");
    if (numberOfSeats == null) throw new IllegalArgumentException("number of seats cannot be null");
    if (numberOfSeats &lt; 1) throw new IllegalArgumentException("number of seats must be positive");
    return note;
  }
</pre>

<p>An obvious move, but a bad one, as this will break the code.
      If we pass a null date into the function, it will add an error
      to the notification, but then merrily attempt to parse it and
      throw a null pointer exception - which isn't the exception we
      were looking for.</p>

<p>So the non-obvious, but more effective thing to do in this
      case is to go backwards. </p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  public Notification validation() {
    Notification note = new Notification();
    if (date == null) throw new IllegalArgumentException("date is missing");
    LocalDate parsedDate;
    try {
      parsedDate = LocalDate.parse(date);
    }
    catch (DateTimeParseException e) {
      throw new IllegalArgumentException("Invalid format for date", e);
    }
    if (parsedDate.isBefore(LocalDate.now())) throw new IllegalArgumentException("date cannot be before today");
    if (numberOfSeats == null) throw new IllegalArgumentException("number of seats cannot be null");
    if (numberOfSeats &lt; 1) <p class="highlight">note.addError</p>("number of seats must be positive");
    return note;
  }
</pre>

<p>The previous check is a null check, so we need to use a
      conditional to avoid creating a null pointer exception.</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  public Notification validation() {
    Notification note = new Notification();
    if (date == null) throw new IllegalArgumentException("date is missing");
    LocalDate parsedDate;
    try {
      parsedDate = LocalDate.parse(date);
    }
    catch (DateTimeParseException e) {
      throw new IllegalArgumentException("Invalid format for date", e);
    }
    if (parsedDate.isBefore(LocalDate.now())) throw new IllegalArgumentException("date cannot be before today");
<p class="highlight">    if (numberOfSeats == null) note.addError("number of seats cannot be null");
    else if (numberOfSeats &lt; 1) note.addError("number of seats must be positive");</p>
    return note;
  }
</pre>

<p>I see the next check involves a different field. Together
      with having to introduce a conditional with the previous
      refactoring, I'm now thinking this validation method is getting
      too complex and could do with being decomposed. So I extract the
      number validation parts.</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  public Notification validation() {
    Notification note = new Notification();
    if (date == null) throw new IllegalArgumentException("date is missing");
    LocalDate parsedDate;
    try {
      parsedDate = LocalDate.parse(date);
    }
    catch (DateTimeParseException e) {
      throw new IllegalArgumentException("Invalid format for date", e);
    }
    if (parsedDate.isBefore(LocalDate.now())) throw new IllegalArgumentException("date cannot be before today");
<p class="highlight">    validateNumberOfSeats(note);</p>
    return note;
  }

  private void validateNumberOfSeats(Notification note) {
    if (numberOfSeats == null) note.addError("number of seats cannot be null");
    else if (numberOfSeats &lt; 1) note.addError("number of seats must be positive");
  }
</pre>

<p>Looking at the extracted validation for the number, I don't
      really like its structure. I don't like using if-then-else
      blocks in validation, since it can easily lead to overly nested
      code. I prefer linear code that aborts once it can't go on any
      further, which we can do with a guard clause. So I apply
      <a href="http://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html">Replace Nested Conditional with Guard Clauses</a>.</p>

<p class="code-label">class BookingRequest&#8230;
</p>

<pre>  private void validateNumberOfSeats(Notification note) {
    if (numberOfSeats == null) {
      note.addError("number of seats cannot be null");
      return;
    }
    if (numberOfSeats &lt; 1) note.addError("number of seats must be positive");
  }
</pre>

<p>
        when we refactor we
      should always try to take the smallest steps we can that
      preserve behavior
      </p>
<p>My decision to go backwards in order to keep the code green
      is an example of a crucial element of refactoring. Refactoring
      is a specific technique to restructure code through a series of
      behavior-preserving transformations. So when we refactor we
      should always try to take the smallest steps we can that
      preserve behavior. By doing this we reduce the chances of an
      error that will trap us in the debugger</p>

<h2>Moving up the stack</h2>

<p>Once we have the new method, the next task is to look at the
      callers of the original check method and consider adjusting them
      to make use of the new validate method instead. This will entail
      a broader look at how validation fits into the flow of the
      application, so it's outside the scope of this refactoring. But
      the medium-term target should be to eliminate the use of
      exceptions in any circumstance where we might expect validation failures. </p>

<p>In many cases this should lead to being able to get rid of
      the check method entirely. In which case any tests on that
      method should be reworked to use the validate method. We might
      also want to adjust the tests to probe for proper collection of
      multiple errors using the notification.</p>


<p class="shares">Share: <a href="https://twitter.com/intent/tweet?url=http://martinfowler.com/articles/replaceThrowWithNotification.html&amp;text=Replacing%20Throwing%20Exceptions%20with%20Notification%20in%20Validations" title="Share on Twitter"><img src="/t_mini-a.png"></a><a href="https://facebook.com/sharer.php?u=http://martinfowler.com/articles/replaceThrowWithNotification.html" title="Share on Facebook"><img src="/fb-icon-20.png"></a><a href="https://plus.google.com/share?url=http://martinfowler.com/articles/replaceThrowWithNotification.html" title="Share on Google Plus"><img src="/gplus-16.png"></a></p>

<h2>For articles on similar topics&#8230;</h2>

<p>&#8230;take a look at the tag: </p>
</div>

<p class="info">
Posted Sat 20 June 2015
 by <a class="url fn" href="./author/itech001.html">itech001</a>
in <a href="./category/ciandcd.html">ciandcd</a>
</p>

</article>
</div>
<!-- /Content -->

<!-- Side bar -->
<nav class="col-lg-3">

<h2>Categories</h2>
<ul class="nav nav-pills nav-stacked">
  <li class="active"><a href="./category/ciandcd.html">ciandcd</a></li>
  <li ><a href="./category/devops.html">devops</a></li>
  <li ><a href="./category/scm.html">scm</a></li>
  <li ><a href="./category/zh.html">zh</a></li>
</ul>

<h2>Links</h2>
<ul class="nav nav-pills nav-stacked">
  <li><a href="http://getpelican.com/">Pelican</a></li>
  <li><a href="http://python.org/">Python.org</a></li>
  <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
</ul>

<h2>Social</h2>
<ul class="nav nav-pills nav-stacked">
  <li><a href="http://www.ciandcd.com/feeds/rss.xml" type="application/rss+xml" rel="alternate">Site Feed</a></li>

  <li><a href="https://github.com/ciandcd">GITHUB</a></li>
</ul>

</nav>
<!-- /Side bar -->

</div>
<!-- /Main block -->

<!-- Footer -->
<div class="row"><div class="col-lg-12">
<footer><small>
Built using <a href="http://pelican.notmyidea.org/">Pelican</a> and
<a href="http://twitter.github.com/bootstrap">Bootstrap</a>.
</small></footer>
</div></div>
<!-- /Footer -->

</div></section>
<!-- /Body -->

<script src="./theme/js/jquery.js"></script>
<script src="./theme/js/bootstrap.js"></script>


</body>
</html>