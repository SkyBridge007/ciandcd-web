<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>
    Bliki: Yagni - ciandcd</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="./theme/css/bootstrap.css" rel="stylesheet" type="text/css"/>
  <link href="./theme/css/main.css" rel="stylesheet" type="text/css"/>
  <link href="./theme/css/pygment.css" rel="stylesheet" type="text/css"/>
  <link href="http://fonts.googleapis.com/css?family=Chelsea+Market" rel="stylesheet" type="text/css"/>
<link href="./feeds/rss.xml" rel="alternate" type="application/atom+xml" title="ciandcd RSS" />


  <!--[if lt IE 9]>
    <script src="https://raw.github.com/aFarkas/html5shiv/master/dist/html5shiv.js"></script>
  <![endif]-->
</head>

<!--
bootstrap-itech - a Pelican theme using Bootstrap
-->
<body>
<a href="https://github.com/ciandcd">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" />
</a>
<!-- Header -->
<header><div class="container">
<h1 class="page-header"><a href="./index.html">ciandcd</a>
<h4>continuous integration and continuous delivery</h4></h1>
</div></header>
<!-- /Header -->

<!-- Body -->
<section id="body"><div class="container-fluid">

<!-- Nav bar -->
<div class="row"><div class="col-lg-12">
<nav class="navbar navbar-default"><div class="collapse navbar-collapse">
<ul class="nav navbar-nav">
  <li><a href="./index.html">Home</a></li>



</ul>
</div></nav>
</div></div>
<!-- /Nav bar -->

<!-- Main block -->
<div class="row">

<!-- Content -->
<div class="col-lg-9">
<article>
<h1>
    Bliki: Yagni</h1>

<div> 

 

 

<p class="tagLabel">tags:</p>

<p class="clear"></p>

<p>Yagni originally is an acronym that stands for "You Aren't Gonna
  Need It". It is a mantra from <a href="ExtremeProgramming.html">ExtremeProgramming</a>
  that's often used generally in agile software teams. It's a
  statement that some capability we presume our software needs in the future
  should not be built now because "you aren't gonna need it". </p>

<p>Yagni is a way to refer to the XP practice of Simple Design (from
  the first edition of <a href="http://www.amazon.com/gp/product/0321278658?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321278658">The White Book</a><img src="http://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&amp;l=as2&amp;o=1&amp;a=0321601912" width="1" height="1" border="0" alt="">, the second edition refers to
  the related notion of "incremental design"). <a href="#footnote-origin">[1]</a> Like many elements of XP, it's a sharp contrast to
  elements of the widely held principles of software engineering in
  the late 90s. At that time there was a big push for careful up-front
  planning of software development.</p>

<p>Let's imagine I'm working with a startup in Minas Tirith selling
  insurance for the shipping business. Their software system is broken
  into two main components: one for pricing, and one for sales. The
  dependencies are such that they can't usefully build
  sales software until the relevant pricing software is completed.</p>

<p>At the moment, the team is working on updating the pricing
  component to add support for risks from storms. They know that in six
  months time, they will need to also support pricing for piracy
  risks. Since they are currently working on the pricing engine they consider
  building the presumptive feature <a href="#footnote-presumptive-feature">[2]</a> for piracy pricing now, since that way the pricing
  service will be complete before they start working on the sales
  software.</p>

<p>Yagni argues against this, it says that since you won't need
  piracy pricing for six months you shouldn't build it until it's
  necessary. So if you think it will take two months to build this
  software, then you shouldn't start for another four months
  (neglecting any buffer time for schedule risk and updating the sales
  component). </p>

<p>The first argument for yagni is that while we may now think we
  need this presumptive feature, it's likely that we will be wrong.
  After all the context of agile methods is an acceptance that we
  welcome changing requirements. A plan-driven requirements guru might
  counter argue that this is because we didn't do a good-enough job of
  our requirements analysis, we should have put more time and effort
  into it. I counter that by pointing out how difficult and costly it is to
  figure out your needs in advance, but even if you can, you can still
  be blind-sided when the Gondor Navy wipes out the pirates, thus
  undermining the entire business model.</p>

<p>In this case, there's an obvious cost of the presumptive feature
  - the <b>cost of build</b>: all the effort spent on analyzing, programming,
  and testing this now useless feature.</p>

<p>But let's consider that we were completely correct with our
  understanding of our needs, and the Gondor Navy didn't wipe out the
  pirates. Even in this happy case, building the
  presumptive feature incurs two
  serious costs. The first cost is the cost of delayed value. By
  expending our effort on the piracy pricing software we didn't build
  some other feature.  If we'd instead put our energy into building
  the sales software for weather risks, we could have put a full
  storm risks feature into production and be generating revenue two
  months earlier. This <b>cost of delay</b> due to the presumptive feature is
  two months revenue from storm insurance.</p>

<p>The common reason why people build presumptive features is
  because they think it will be cheaper to build it now rather than
  build it later. But that cost comparison has to be made at least
  against the cost of delay,  preferably factoring in the
  probability that you're building an unnecessary feature, for which
  your odds are at least &#8532;. <a href="#footnote-kohavi">[3]</a></p>

<p>Often people don't think through the comparative cost of building
  now to building later. One approach I use when mentoring developers
  in this situation is to ask them to imagine any refactoring they
  would have to do later to introduce the capability when it's needed.
  Often that thought experiment is enough to convince them that it
  won't be significantly more expensive to add it later. Another
  result from such an imagining is to add something that's easy to do
  now, adds minimal complexity, yet significantly reduces the later
  cost. Using lookup tables for error messages rather than inline
  literals are an example that are simple yet
  make later translations easier to support.</p>

<blockquote class="twitter-tweet" lang="en">
    Reminder, any extensibility point that&#8217;s never used isn&#8217;t just
    wasted effort, it&#8217;s likely to also get in your way as well
  <a href="https://twitter.com/jeremydmiller/status/568797862441586688">-- Jeremy Miller</a></blockquote>
<p>The cost of delay is one cost that a successful presumptive
  feature imposes, but another is the <b>cost of carry</b>. The code for the
  presumptive feature adds some complexity to the software, this
  complexity makes it harder to modify and debug that software, thus
  increasing the cost of other features. The extra complexity from
  having the piracy-pricing feature in the software might add a couple
  of weeks to how long it takes to build the storm insurance sales
  component. That two weeks hits two ways: the additional cost to
  build the feature, plus the additional cost of delay since it look
  longer to put it into production. We'll incur a cost of carry on every
  feature built between now and the time the piracy insurance software
  starts being useful. Should we never need the piracy-pricing
  software, we'll incur a cost of carry on every feature built until
  we remove the piracy-pricing feature (assuming we do), together with
  the cost of removing it.</p>

<p>So far I've divided presumptive features in two categories:
  successful and unsuccessful. Naturally there's really a spectrum
  there, and with one point on that spectrum that's worth highlighting: the right
  feature built wrong. Development teams are always learning, both
  about their users and about their code base. They learn about the
  tools they're using and these tools go through regular upgrades. They
  also learn about how their code works together. All this means that
  you often realize that a feature coded six months ago wasn't done
  the way you now realize it should be done. In that case you have
  accumulated <a href="TechnicalDebt.html">TechnicalDebt</a> and have to
  consider the <b>cost of repair</b> for that feature or the on-going
  costs of working around its difficulties.</p>

<p>So we end up with three classes of presumptive features, and four
  kinds of costs that occur when you neglect yagni for them.</p>
<img src="images/yagni/sketch.png">
<p>My insurance example talks about relatively user-visible
  functionality, but the same argument applies for abstractions to
  support future flexibility. When building the storm risk calculator,
  you may consider putting in abstractions and parameterizations now
  to support piracy and other risks later. Yagni says not to do this,
  because you may not need the other pricing functions, or if you do your
  current ideas of what abstractions you'll need will not match what
  you learn when you do actually need them. This doesn't mean to
  forego all abstractions, but it does mean any abstraction that makes
  it harder to understand the code for current requirements is
  presumed guilty.</p>

<p>Yagni is at its most visible with larger features, but you see it
  more frequently with small things. Recently I wrote some code that
  allows me to highlight part of a line of code. For this, I allow the
  highlighted code to be specified using a regular expression. One
  problem I see with this is that since the whole regular expression
  is highlighted, I'm unable to deal with the case where I need the
  regex to match a larger section than what I'd like to highlight. I
  expect I can solve that by using a group within the regex and
  letting my code only highlight the group if a group is present. But I
  haven't needed to use a regex that matches more than what I'm
  highlighting yet, so I haven't extended my highlighting code to
  handle this case - and won't until I actually need it. For similar
  reasons I don't add fields or methods until I'm actually ready to
  use them.</p>

<p>Small yagni decisions like this fly under the radar of project
  planning. As a developer it's easy to spend an hour adding an abstraction
  that we're sure will soon be needed. Yet all the arguments above
  still apply, and a lot of small yagni decisions add up to
  significant reductions in complexity to a code base, while speeding
  up delivery of features that are needed more urgently.</p>

<p>Now we understand why yagni is important we can dig into a common
  confusion about yagni. <b>Yagni only applies to capabilities built
  into the software to support a presumptive feature, it does not
  apply to effort to make the software easier to modify.</b> Yagni is
  only a viable strategy if the code is easy to change, so expending
  effort on refactoring isn't a violation of yagni because refactoring
  makes the code more malleable. Similar reasoning applies for
  practices like <a href="SelfTestingCode.html">SelfTestingCode</a> and
  <a href="ContinuousDelivery.html">ContinuousDelivery</a>. These are <a href="/articles/designDead.html">enabling practices for evolutionary
  design</a>, without them yagni turns from a beneficial practice into
  a curse. But if you do have a malleable code base, then yagni
  reinforces that flexibility. Yagni has the curious property that it
  is both enabled by and enables evolutionary design.
  </p>

<p>
    Yagni is not a justification for neglecting the health of your
    code base. Yagni requires (and enables) malleable code.
  </p>
<p>I also argue that yagni only applies when you introduce extra
  complexity now that you won't take advantage of until later. If you
  do something for a future need that doesn't actually increase the
  complexity of the software, then there's no reason to invoke
  yagni.</p>

<p>Having said all this, there are times when applying yagni does cause
  a problem, and you are faced with an expensive change when an
  earlier change would have been much cheaper. The tricky thing here
  is that these cases are hard to spot in advance, and much easier to
  remember than the cases where yagni saved effort <a href="#footnote-availability">[4]</a>. My sense is that yagni-failures are relatively
  rare and their costs are easily outweighed by when yagni
  succeeds.</p>

<h2>Further Reading</h2>

<p>My essay <a href="/articles/designDead.html">Is Design
    Dead</a> talks in more detail about the role of design and
    architecture in agile projects, and thus role yagni plays as an
    enabling practice.</p>

<p>This principle was first discussed and fleshed out on <a href="http://c2.com/cgi/wiki?YouArentGonnaNeedIt">Ward's Wiki</a>.</p>
<p class="acknowledgements">
<h2>Acknowledgements</h2>

    Rachel Laycock talked through this post with me and played a
    critical role in its final organization. Chet Hendrickson and
    Steven Lowe reminded
    me to discuss small-scale yagni decisions.

    Rebecca Parsons, Alvaro Cavalcanti, Mark Taylor, Aman King, Rouan
    Wilsenach, Peter Gillard-Moss, Kief Morris, Ian Cartwright, James
    Lewis, Kornelis Sietsma, and Brian Mason participated in an insightful
    discussion about drafts of this article on our internal mailing list.
    
  </p>

<p class="shares">Share: <a href="https://twitter.com/intent/tweet?url=http://martinfowler.com/bliki/Yagni.html&amp;text=Bliki:%20Yagni" title="Share on Twitter"><img src="/t_mini-a.png"></a><a href="https://facebook.com/sharer.php?u=http://martinfowler.com/bliki/Yagni.html" title="Share on Facebook"><img src="/fb-icon-20.png"></a><a href="https://plus.google.com/share?url=http://martinfowler.com/bliki/Yagni.html" title="Share on Google Plus"><img src="/gplus-16.png"></a></p>
</div>

<p class="info">
Posted Sun 21 June 2015
 by <a class="url fn" href="./author/itech001.html">itech001</a>
in <a href="./category/devops.html">devops</a>
</p>

</article>
</div>
<!-- /Content -->

<!-- Side bar -->
<nav class="col-lg-3">

<h2>Categories</h2>
<ul class="nav nav-pills nav-stacked">
  <li ><a href="./category/ciandcd.html">ciandcd</a></li>
  <li class="active"><a href="./category/devops.html">devops</a></li>
  <li ><a href="./category/scm.html">scm</a></li>
  <li ><a href="./category/zh.html">zh</a></li>
</ul>

<h2>Links</h2>
<ul class="nav nav-pills nav-stacked">
  <li><a href="http://getpelican.com/">Pelican</a></li>
  <li><a href="http://python.org/">Python.org</a></li>
  <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
</ul>

<h2>Social</h2>
<ul class="nav nav-pills nav-stacked">
  <li><a href="http://www.ciandcd.com/feeds/rss.xml" type="application/rss+xml" rel="alternate">Site Feed</a></li>

  <li><a href="https://github.com/ciandcd">GITHUB</a></li>
</ul>

</nav>
<!-- /Side bar -->

</div>
<!-- /Main block -->

<!-- Footer -->
<div class="row"><div class="col-lg-12">
<footer><small>
Built using <a href="http://pelican.notmyidea.org/">Pelican</a> and
<a href="http://twitter.github.com/bootstrap">Bootstrap</a>.
</small></footer>
</div></div>
<!-- /Footer -->

</div></section>
<!-- /Body -->

<script src="./theme/js/jquery.js"></script>
<script src="./theme/js/bootstrap.js"></script>


</body>
</html>